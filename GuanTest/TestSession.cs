using System;
using System.Collections.Generic;
using System.Configuration;
using System.IO;
using System.Threading;
using System.Diagnostics.CodeAnalysis;
using Guan.Common;

namespace GuanTest
{
    /// <summary>
    /// TestSession provides commands that are common for all
    /// test sessions.  It manages the command buffer, controls
    /// logging and feeds the test dispatcher the test commands.
    /// The following are TestSession common commands (internal
    /// commands).
    /// !q:                 Quit the session.
    /// !abort:             Abort the session (without calling CloseSession).
    /// !load,script        Load commands from the script (replace script with
    ///                     the actual script file name).
    /// !save,script        Save commands executed so far to the script.
    /// !resume[,label]     Rerun the commands from the last error log.
    /// !auto,0             Disable auto mode.
    /// !auto,1             Enable on auto mode.
    /// !reset              Reset session state.
    /// !label,name         Label the session with the name specified.  The name
    ///                     is used for naming the log files.
    /// !pause              Wait for user input to proceed with next command.
    /// !pause,timeout      Wait for the number of seconds specified.
    /// </summary>
    public class TestSession : IDisposable
    {
        /// <summary>
        /// Test dispatcher
        /// </summary>
        private ITestDispatcher m_dispatcher;

        /// <summary>
        /// Session label
        /// </summary>
        private string m_label;

        /// <summary>
        /// Whether to enable command log.
        /// </summary>
        private bool m_enableLog;

        /// <summary>
        /// File name for the command log.
        /// </summary>
        private string m_logFile;

        /// <summary>
        /// The writer for the current history log.
        /// </summary>
        private StreamWriter m_logWriter;

        /// <summary>
        /// Command buffer
        /// </summary>
        private Queue<string> m_commands;

        /// <summary>
        /// Test session status.
        /// 0 while the session is running.
        /// Less than 0 if the session has encountered error
        /// Greater than 0 if the session is to be completed
        /// </summary>
        private int m_result;

        /// <summary>
        /// Whether exit the session when encountering error.
        /// </summary>
        private bool m_autoMode;

        /// <summary>
        /// Whether the write the error log.
        /// </summary>
        private bool m_logError;

        /// <summary>
        /// Whether in interactive mode.
        /// </summary>
        private int m_intercept;

        /// <summary>
        /// Whether the test session is generating script only.
        /// </summary>
        private bool m_scriptMode;

        /// <summary>
        /// Whether to enable step mode.
        /// </summary>
        private bool m_stepMode;

        private bool m_ignoreError;

        /// <summary>
        /// The source for TestSession event logging.  The various
        /// sub source defined below are concatenated to form
        /// the full source.  Besides event logging filter purposes,
        /// the sources are also used to inform TestSession the
        /// current execution status.
        /// </summary>
        private const string TraceSession = "TestSession";

        /// <summary>
        /// For reports generated by the session infrastructure itself.
        /// </summary>
        public const string SystemReport = "System";

        /// <summary>
        /// For error reports.
        /// </summary>
        public const string ErrorReport = "Error";

        /// <summary>
        /// For progress report when an async test action is pending.
        /// </summary>
        public const string PendingReport = "Pending";

        /// <summary>
        /// For progress report when an async test action is completed.
        /// </summary>
        public const string CompletionReport = "Completion";

        /// <summary>
        /// For reporting test results.
        /// </summary>
        public const string ResultReport = "Result";

        /// <summary>
        /// Information that is related to global state change.
        /// </summary>
        public const string StateReport = "State";

        /// <summary>
        /// For informational test report.
        /// </summary>
        public const string InformationReport = "Information";

        /// <summary>
        /// For verbose test report.
        /// </summary>
        public const string VerboseReport = "Verbose";

        /// <summary>
        /// Constructor.
        /// </summary>
        /// <param name="label">The label of the test session.
        /// The label identifies the the session and is used to
        /// name the log file etc.
        /// </param>
        /// <param name="autoMode">Whether the test is in auto mode.
        /// For auto mode test, the session will complete and return
        /// -1 when encountering an error.  For non-auto mode, the
        /// session will wait for user commands.
        /// </param>
        /// <param name="dispatcher">The test dispatcher</param>
        public TestSession(string label, bool autoMode,
                           ITestDispatcher dispatcher)
        {
            m_commands = new Queue<string>();
            m_result = 0;
            m_autoMode = autoMode;
            m_scriptMode = false;
            m_logError = false;
            m_ignoreError = false;
            m_stepMode = false;
            m_dispatcher = dispatcher;

            try
            {
                bool canAccessConsole = Console.KeyAvailable;
                m_intercept = 0;
            }
            catch (InvalidOperationException)
            {
                m_intercept = -1;
            }

            Label = label;
        }

        /// <summary>
        /// The test dispatch associated with the session.
        /// </summary>
        protected ITestDispatcher Dispatcher
        {
            get 
            { 
                return (m_dispatcher); 
            }
        }

        /// <summary>
        /// Whether the session is in auto mode.
        /// </summary>
        public bool IsAutoMode
        {
            get 
            { 
                return (m_autoMode); 
            }
            set 
            { 
                m_autoMode = value; 
            }
        }

        /// <summary>
        /// Whether the test is generating script only.
        /// </summary>
        public bool IsScriptMode
        {
            get
            {
                return m_scriptMode;
            }
            set
            {
                m_scriptMode = value;
            }
        }

        public bool EnableLog
        {
            get
            {
                return m_enableLog;
            }
            set
            {
                m_enableLog = value;
            }
        }

        /// <summary>
        /// Whether to write error log.
        /// </summary>
        public bool LogError
        {
            get 
            { 
                return (m_logError); 
            }
            set 
            { 
                m_logError = value; 
            }
        }


        /// <summary>
        /// Open the test session.  Initialization of the session
        /// should be performed here.
        /// </summary>
        /// <returns>Whether the open is successful</returns>
        protected virtual bool OpenSession()
        {
            return m_dispatcher.Open(this);
        }

        protected virtual void Dispose(bool disposing)
        {
            if (disposing)
            {
                CloseSession();
            }
        }

        public void Dispose()
        {
            Dispose(true);
        }

        /// <summary>
        /// Cleanup the test session.
        /// </summary>
        protected virtual void CloseSession()
        {
            if (m_dispatcher != null)
            {
                m_dispatcher.Close();
                m_dispatcher = null;
            }

            if (m_logWriter != null)
            {
                m_logWriter.Close();
                m_logWriter = null;
            }
        }

        private string GetConsoleInput()
        {
            Console.Write(">");
            return Console.ReadLine();
        }

        /// <summary>
        /// Get the next command.  By default the command is read
        /// from the console.
        /// If the command is supplied dynamically, the command
        /// supplier should call AddInput to add commands to the
        /// command buffer and then return null.
        /// </summary>
        /// <returns>The command</returns>
        [SuppressMessage("Microsoft.Design", "CA1024", Justification="Time consuming operation.")]
        protected virtual string GetInput()
        {
            return GetConsoleInput();
        }

        /// <summary>
        /// This method can be called to add commands to the command
        /// buffer so that they can be consumed by the session.
        /// </summary>
        /// <param name="line">The command to add to command buffer</param>
        protected void AddInput(string line)
        {
            m_commands.Enqueue(line);
        }

        /// <summary>
        /// Report a message to the session.
        /// </summary>
        /// <param name="src">Report source</param>
        /// <param name="format">Report format string</param>
        /// <param name="args">Report arguments</param>
        public virtual void Report(string src, string format, params object[] args)
        {
            if (src == null)
            {
                throw new ArgumentNullException("src");
            }

            // If the session is already terminated, ignore the reports.
            //
            if (m_result != 0)
            {
                return;
            }

            // Log error report as error, System report as Console output and everything
            // else as informational event.
            //
            if (src.StartsWith(ErrorReport))
            {
                EventLog.WriteError(TraceSession + "." + src, format, args);
            }
            else if (src == ResultReport)
            {
                EventLog.WriteInfo1(TraceSession + "." + src, format, args);
            }
            else if (src == SystemReport)
            {
                EventLog.WriteInfo2(TraceSession + "." + src, format, args);
            }
            else
            {
                EventLog.WriteInfo(TraceSession + "." + src, format, args);
            }
        }

        private void OnError()
        {
            // Clear pending commands from the buffer
            //
            m_commands.Clear();

            // Fail the session if in auto mode
            //
            if (m_autoMode)
            {
                m_result = -1;
            }
            else
            {
                m_intercept = 1;
            }
        }

        private void Reset()
        {
            m_dispatcher.Reset();
        }

        public string Label
        {
            get
            {
                return (m_label);
            }
            set
            {
                m_label = value;

                // Close existing writer.
                //
                if (m_logWriter != null)
                {
                    m_logWriter.Close();
                    m_logWriter = null;
                }

                // Create the current writer using the new label.
                //

                while (m_enableLog && m_logWriter == null)
                {
                    try
                    {
                        m_logFile = "current-" + m_label + ".log";
                        m_logWriter = new StreamWriter(new FileStream(m_logFile, FileMode.Create, FileAccess.Write, FileShare.Read));
                    }
                    catch (IOException)
                    {
                        m_label = value + DateTime.Now.Millisecond.ToString();
                    }
                }
            }
        }

        private void Pause(string param)
        {
            if (IsScriptMode)
            {
                return;
            }

            if (param != null)
            {
                int wait = 0;
                if (param.EndsWith("ms"))
                {
                    param = param.Substring(0, param.Length - 2);
                    Utility.TryParse<int>(param, out wait);
                }
                else
                {
                    if (Utility.TryParse<int>(param, out wait))
                    {
                        wait *= 1000;
                    }
                }

                if (wait > 0)
                {
                    Thread.Sleep(wait);
                }
            }
            else
            {
                Console.WriteLine("Press enter to continue...");
                Console.ReadLine();
            }
        }

        private void Resume(string param)
        {
            if (param == null)
            {
                param = m_label;
            }

            string result = null;

            // Look for the latest error log file
            //
            string fileName = "error-" + param + ".log";
            int seq = 0;
            while (File.Exists(fileName))
            {
                result = fileName;
                ++seq;
                fileName = "error-" + param + "-" + seq + ".log";
            }

            if (result == null)
            {
                Report(SystemReport, "log file not found");
            }
            else
            {
                Load(result);
            }
        }

        /// <summary>
        /// Load a script into the current session
        /// </summary>
        /// <param name="fileName">script file path</param>
        public void Load(string fileName)
        {
            bool isLast = (m_commands.Count == 0);

            Queue<string> tmp = m_commands;
            m_commands = new Queue<string>(tmp.Count * 2);

            using (StreamReader reader = new StreamReader(fileName))
            {
                int added = 0;
                string line;
                while ((line = reader.ReadLine()) != null)
                {
                    line = line.Trim();

                    // Insert the commands read from the file.
                    // Ignore session termination commands unless there is no more
                    // command in the buffer.
                    //
                    if ((line.Length != 0) &&
                        ((isLast == true) ||
                         (line.StartsWith("!q") == false && line.StartsWith("!abort") == false)))
                    {
                        AddInput(line);
                        added++;
                    }
                }
            }

            while (tmp.Count > 0)
            {
                m_commands.Enqueue(tmp.Dequeue());
            }
        }

        private void Save(string fileName, string errorMsg)
        {
            using (StreamWriter writer = new StreamWriter(fileName))
            {
                string prev = null;

                using (StreamReader reader = new StreamReader(new FileStream(m_logFile, FileMode.Open, FileAccess.Read, FileShare.ReadWrite)))
                {
                    string current;

                    while ((current = reader.ReadLine()) != null)
                    {
                        if (current.StartsWith("!") || current.StartsWith("##"))
                        {
                            continue;
                        }

                        if (prev != null)
                        {
                            writer.WriteLine(prev);
                        }
                        prev = current;
                    }
                }

                if (prev == null)
                {
                    return;
                }

                if (errorMsg != null)
                {
                    // Wrap error message as comments
                    //
                    errorMsg = "##" + errorMsg.Replace("\n", "\n##");

                    writer.WriteLine("##" + prev);
                    writer.WriteLine(errorMsg);

                    // Disable logging.
                    //
                    writer.WriteLine("!log,0");
                    writer.WriteLine("!pause");
                    writer.WriteLine(prev);

                    // Enable logging again.
                    writer.WriteLine("!log,1");
                }
                else
                {
                    writer.WriteLine(prev);
                }
            }

            Report(SystemReport, fileName + " saved");
        }

        private string CheckIntercept()
        {
            if (m_intercept < 0)
            {
                return null;
            }

            string line = null;
            if (m_intercept > 0 || Console.KeyAvailable)
            {
                line = GetConsoleInput();
                m_intercept = 1;
            }

            return line;
        }

        private string GetNextCommand()
        {
            string line = CheckIntercept();
            if (line != null)
            {
                return line;
            }

            // First try to get command from buffer
            //
            if (m_commands.Count > 0)
            {
                EventLog.WriteInfo2(TraceSession + ".Command", "{0}", m_commands.Peek());
                if (m_stepMode)
                {
                    Console.WriteLine("Press enter to execute...");
                    Console.ReadLine();
                }
            }
            else
            {
                // Buffer is empty, try to get new command
                //
                line = GetInput();

                if (line != null)
                {
                    m_commands.Enqueue(line);
                }

                // Still no command available?
                //
                if (m_commands.Count == 0)
                {
                    return null;
                }

                // Command available in buffer now, call again.
                if (line == null)
                {
                    return GetNextCommand();
                }
            }

            return m_commands.Dequeue();
        }

        private void SetConfig(string param)
        {
            string key;
            string value;

            int index = param.IndexOf('=');
            if (index < 0)
            {
                key = param;
                value = string.Empty;
            }
            else
            {
                key = param.Substring(0, index);
                value = param.Substring(index + 1);
            }

            ConfigurationManager.AppSettings[key] = value;
            EventLog.RefreshConfig();
        }

        [SuppressMessage("Microsoft.Design", "CA1031", Justification = "Report exception to user to allow troubleshooting without bring down the process.")]
        private void ExecuteInternalCommand(string command)
        {
            string type;
            string param = null;

            int i = command.IndexOf(' ');
            if (i > 0)
            {
                type = command.Substring(0, i);
                if (i + 1 < command.Length)
                {
                    param = command.Substring(i + 1);
                }
            }
            else
            {
                type = command;
            }

            try
            {
                switch (type)
                {
                    case "abort":
                        m_result = -1;
                        break;
                    case "exit":
                        m_result = int.Parse(param);
                        break;
                    case "pause":
                        Pause(param);
                        break;
                    case "load":
                        Load(param);
                        break;
                    case "save":
                        Save(param, null);
                        break;
                    case "label":
                        Label = param;
                        break;
                    case "resume":
                        Resume(param);
                        break;
                    case "reset":
                        Reset();
                        break;
                    case "intercept":
                        m_intercept = int.Parse(param);
                        break;
                    case "error":
                        if (param == "ignore")
                        {
                            m_ignoreError = true;
                        }
                        else if (param == "log")
                        {
                            m_logError = true;
                        }
                        break;
                    case "step":
                        Utility.TryParse(param, out m_stepMode);
                        break;
                    case "config":
                        SetConfig(param);
                        break;
                    case "gc":
                        GC.Collect();
                        break;
                }
            }
            catch (Exception e)
            {
                Report(ErrorReport, "Error while executing internal command: {0}\n{1}", command, e);

                OnError();
            }
        }

        /// <summary>
        /// Execute test commands (commands that are specific to test dispatcher).
        /// </summary>
        /// <param name="command">The test command</param>
        protected virtual void ExecuteTestCommand(string command)
        {
            try
            {
                if (m_dispatcher.ExecuteCommand(command) == false)
                {
                    Report(SystemReport, "Invalid command: {0}", command);
                }
            }
            catch (Exception e)
            {
                if (e is IntendedException)
                {
                    // This is an intended crash.
                    //
                    throw;
                }

                string msg = string.Format("Execution exception at {0}: {1}", m_label, e);
                Report(ErrorReport, "{0}", msg);

                if (m_logError)
                {
                    string fileName = "error-" + m_label + ".log";
                    int seq = 0;
                    while (File.Exists(fileName))
                    {
                        ++seq;
                        fileName = "error-" + m_label + "-" + seq + ".log";
                    }

                    Save(fileName, msg);
                }

                if (!m_ignoreError)
                {
                    OnError();
                }
            }
        }

        private int Run()
        {
            if (OpenSession() == false)
            {
                m_result = -1;
            }

            while (m_result == 0)
            {
                string command = GetNextCommand();
                if (command == null || command.StartsWith("!q"))
                {
                    LogCommand("!q");
                    m_result = 1;
                }
                else
                {
                    command = command.Trim();

                    LogCommand(command);

                    // Is this an internal command?
                    if (command.StartsWith("!"))
                    {
                        command = command.Substring(1);
                        ExecuteInternalCommand(command);
                    }
                    else if (command.StartsWith("#") == false && command.Length > 0)
                    {
                        ExecuteTestCommand(command);
                    }
                }
            }

            if (m_result > 0)
            {
                CloseSession();
            }

            return m_result;
        }

        private void LogCommand(string command)
        {
            if (m_logWriter != null)
            {
                if (command.StartsWith("!load,") || command == "!resume")
                {
                    // Such commands cannot be put into the command buffer
                    // because they will load the actual commands to the
                    // buffer instead.
                    //
                    m_logWriter.WriteLine("#" + command);
                }
                else
                {
                    m_logWriter.WriteLine(command);
                }

                m_logWriter.Flush();
            }
        }

        /// <summary>
        /// Execute the session.
        /// </summary>
        /// <returns>
        /// 0 if the test is successful.
        /// -1 if the test fails.
        /// -2 if the test intentionally terminate itself in the middle of a test
        /// </returns>
        [SuppressMessage("Microsoft.Design", "CA1031", Justification = "Report exception to user to allow troubleshooting without bring down the process.")]
        public int Execute()
        {
            try
            {
                Run();
            }
            catch (IntendedException)
            {
                m_result = -2;
            }
            catch (Exception e)
            {
                Report(ErrorReport, "Session faulted: " + e.ToString());
                m_result = -1;
            }

            if (m_result > 0)
            {
                m_result = 0;
            }

            return m_result;
        }
    }

    internal class IntendedException : Exception
    {
        public IntendedException(string message)
            : base(message)
        {
        }
    }
}
